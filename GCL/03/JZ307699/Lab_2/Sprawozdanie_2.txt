Imię i nazwisko: Julia Żychowska
Kierunek: Informatyka Stosowana (NS)
Nr. indeksu: 307699
Przedmiot: Metodyki DevOps
Sprawozdanie: 02
Grupa: GĆL03

Sprawozdanie

Zestawienie środowiska
	1. Zainstaluj Docker w systemie linuksowym
	Zainstalowałam dockera w ubuntu poleceniem: "sudo apt install docker.io". (1_1, 1_2) Poleceniem "docker --version" sprawdziłam wersje dockera (1_3), a następnie przetestowałam czy działa odpalając hello-world poleceniem "sudo docker run hello-world" (1_3). Na koniec zainstalowałam docker-compose poleceniem "sudo apt install docker-compose" (1_4), oraz sprawdziłam wersje "docker-compose version" (1_5).
	Screeny: 1_1, 1_2, 1_3, 1_4, 1_5
	2. Zarejestruj się w Docker Hub i zapoznaj z sugerowanymi obrazami
	Zarejestrowałam się na hub.docker.com (2_1) i zapoznałam się z obrazami dostępnymi na tej stronie (2_2).
	Screeny: 2_1, 2_2
	3. Pobierz hello-world, busybox, ubuntu lub fedorę, mysql
hello-world już miałam domyślnie zainstalowane przy instalowaniu dockera, poleceniem "sudo docker images" wyświetlamy wszystkie obrazy jakie mamy zainstalowanie (3_1). Zainstalowałam busybox, ubuntu oraz mysql poleceniami: "sudo docker pull busybox" (3_2), "sudo docker pull ubuntu" (3_3), "sudo docker pull mysql" (3_4). Poleceniem "sudo docker images" wyświetlamy obrazy zainstalowane (3_4).
	Screeny: 3_1, 3_2, 3_3, 3_4
	4. Uruchom busybox
		- Pokaż efekt uruchomienia kontenera
		Po uruchomieniu poleceniem "sudo docker run -it busybox" nic się nie działo. Terminal czekał na dalsze polecenia (4_1).
		- Podłącz się do kontenera interaktywnie i wywołaj numer wersji
		Po wpisaniu "busybox", w miesju oczekiwania po wyżej wymienionym poleceniu, wyświetlilo m.in. numer wersji busybox'a (4_2,4_3). Wersja: BusyBox v1.34.1
		Screeny: 4_1, 4_2, 4_3
	5. Uruchom "system w kontenerze"
		- Zaprezentuj PID1 w kontenerze i procesy dockera na hoście
		Poleceniem "sudo docker run --name="containerUbuntu" -it ubuntu" uruchomiłam kontener o nazwie containerUbuntu na obrazie systemu ubuntu. Następnie poleceniem w kontenerze "ps -aux" wypisałam wszystkie procesy. Proces PID o wartości 1 to głowny proces wywołany jako proces macierzysty kontenra przy jego tworzeniu (5_1). Wypisałam też poleceniem sudo docker ps procesy dockera (5_3).
		Screeny: 5_1, 5_3
		- Zaktualizuj pakiety
		Zaktualizowałam pakiety na uruchomionym kontenerze poleceniem "apt-get update" (5_1, 5_2).
		Screeny: 5_1, 5_2
		- Wyjdź
		Poleceniem exit wyszłam z kontenera (5_2)
		Screeny: 5_2
	6. Pokaż uruchomione ( != "działające" ) kontenery, wyczyść je.
	Poleceniem "sudo docker ps -a wyświetlam wszystkie kontenery (6_1), poleceniem: sudo docker container ls -a --filter status=exited" wyświetlam wszystkie zakończone kontenery (6_2),a poleceniem "sudo docker container prune" usuwam zakończone (6_3). Na koniec sprawdzam co pozostało poleceniem "sudo docker ps -a" (6_3).
	Screeny: 6_1, 6_2, 6_3 
	7. Wyczyść obrazy
	Wyświetliłam poleceniem "sudo docker images" (7_1) wszystkie obrazy. Czyszcząc je napotakłam problemy. Początkowo używałam polecenia "docker rim $(docker images -q) do usunięcia wszystkich obrazów za jednych zamachem. Nie zadziałało (7_1), posunełam się do polecenia docker rmi --force $(docker images -q), ale też nie zadziałało (7_2). Pomyślałam, że zrobię to pojedyńczo poleceniem "sudo docker rmi b05128b000dd" (numer id obrazu). Na początku dla obrazu mysql zadziałało (7_3,7_4), ale napotkało problem przy busybox (7_5). Odkryłam, że chodziło o to, że mam aktywne wciąż 2 kontenery na ubuntu i busybox. Zastopowałam je poleceniem "sudo docker container stop 0580ae3ea20c" (7_5). Następnie poleceniem "sudo docker container prune" usunełam kontenery (7_6). Dalej nie działało polecenie na usunięcie wszystkich obrazów (7_6), ale pojedyńczo już tak (7_7, 7_8). Na koniec wyświetliłam obrazy "sudo docker images" i wszystko było usunięte (7_8).
	Screeny: 7_1, 7_2, 7_3, 7_4, 7_5, 7_6, 7_7, 7_8
Budowanie programu
	1. Znajdź projekt umożliwiający łatwe wywołanie testów jednostkowych
	Wybrałam projekt "easy-sauce" posiadający testy. Link: https://github.com/philipwalton/easy-sauce 
	Screeny: 1_1b
	2. Przeprowadź budowę/konfigurację środowiska
	Na początku zainstalowałam npm, poleceniem "sudo apt install npm" (2_1b, 2_2b). Na koniec zainstalowałam zależności npm, poleceniem "sudo npm install" (2_4b).
	Screeny: 2_1b, 2_2b, 2_4b
	3. Uruchom testy
	Poleceniem "sudo npm test" uruchomiłam testy jednostkowe. Zakończyły się bez żadnych błędów.
	Screeny 3_1b, 4_1b
	4. Ponów ten proces w kontenerze
		- Wybierz i uruchom platformę
		Zainstalowałam obraz ubuntu, poleceniem "sudo docker pull ubuntu" (4_1b). Następnie uruchomiłam kontener na tym obrazie, poleceniem "sudo docker run --name="c_ubuntu" -it ubuntu" (4_2b). 
		Screeny: 4_1b, 4_2b
		- Zaopatrz ją w odpowiednie oprogramowanie wstępne
		Pierwsze zaktualizowałam poleceniem "apt update" (4_2b, 4_3b), następnie zainstalowałam npm "apt install npm" (4_4b, 4_5b). Zainstalowałam również git poleceniem "apt install git" (4_6b, 4_7b).
		Screeny: 4_2b, 4_3b, 4_4b, 4_5b, 4_6b, 4_7b
		- Sklonuj aplikację
		Sklonowałam repozytorium "git clone i adres" (4_8b). 
		Screeny: 4_8b
		- Skonfiguruj środowisko i uruchom build
		Na początek przemieściłam się do pobranego repozytorium - katalog easy-souce i uruchomiłam polecenie "npm install" (4_9b). Następnie uruchomiłam npm build. (4_9b). 
		Screeny: 4_9b
		- Uruchom testy
		Uruchomiłam pomyślnie testy poleceniem npm test (4_9b, 4_10b, 4_11b)
		Screeny: 4_9b, 4_10b, 4_11b
	5. Stwórz Dockerfile, który ma to osiągnąć
	Poleceniem vim Dockerfile, tworzymy nasz Dockerfile. 
		- Na bazie platformowego obrazu...
		Aplikacja jest w środowisku node.js, dlatego obrazem bazowym będzie node. Za pomocą FROM ustalamy obraz w Dockerfile. Polecenie: FROM node.
		- ...doinstaluj wymagania wstępne...
		Na początku ustawiłam katalog roboczy za pomocą "WORKDIR /appES". instalacja npm bez WORKDIR wyrzucała mi błędy przy późniejszym "npm install", ze względów, że instalacja wykonywała się w katalogu głownym kontenera. Jest to potrzebne od pewnej wersji nodejs. Następnie musiałam się zająć aktualizacją pakietów poleceniem "RUN apt-get update". RUN w Dockerfile odpowiada działaniu. Używając również RUN zainstalowałam gita "RUN apt-get install git". 
		- ...sklonuj repozytorium...
		Sklonowałam repozytorium używając polecenia "RUN git clone https://github.com/philipwalton/easy-sauce.git"
		- ...zbuduj kod
		Poleceniem "WORKDIR /appES/easy-sauce" przeniosłam się do repozytorium. Wykonałam "RUN npm install", a na koniec "CMD ["npm","test"].
Te dwa polecenia wykonywane są na plikach znajdujących się wewnątrz obrazu Node. Na koniec zapisałam Dockerfile i wywołałam polecenie "sudo docker build -t easy/sauce:latest ." (5_2b). -t easy/sauce:latest służy do określenia nazwy obrazu za pomocą taga. 
	Screeny 5_1b, 5_2b
	6. Zaprezentuj Dockerfile i jego zbudowanie
	Screeny 5_1b, 5_2b
	7. Na bazie obrazu utworzonego poprzednim dockerfilem stwórz kolejny, który będzie uruchamiał testy
	Na bazie obrazu easy/sauce stworzyłam Dockerfile, który jedynie co robi to uruchamia testy, poleceniem "CMD ["npm", "start"]" (7_1b). Zbudowałam tak jak wcześniej obraz tym razem o nazwie easy/sauce2 (7_2b) i uruchomiłam poleceniem "sudo docker run easy/sauce2:latest" (7_3b, 7_4b). 
	Screeny: 7_1b, 7_2b, 7_3b, 7_4b
Runda bonusowa: kompozycja
	1. Zdefiniuj kompozycję, która stworzy dwie usługi
		- Pierwszą na bazie dockerfile'a budującego
		---------------------------------
		- Drugą na bazie pierwszej
		---------------------------------
	2. Wdróż :)
